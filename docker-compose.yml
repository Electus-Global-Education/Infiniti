# docker-compose.yml

services:
  db:
    image: postgres:15 # Using PostgreSQL version 15
    container_name: postgres_db_dev
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data/ # Persist database data
    env_file:
      - ./.env.db # Load database credentials
    networks:
      - django_network
    healthcheck:
      # Test to check if PostgreSQL is ready
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s # Check every 10 seconds
      timeout: 5s   # Wait 5 seconds for the check to complete
      retries: 5    # Retry 5 times

  web:
    build:
      context: . # Use the current directory as the build context
      dockerfile: Dockerfile # Specify the Dockerfile name
    container_name: django_app_dev
    command: >
      sh -c "python manage.py wait_for_db &&
             python manage.py makemigrations &&
             python manage.py migrate &&
             python manage.py collectstatic --noinput &&
             python manage.py runserver 0.0.0.0:8000"
    # Temp
    # command: tail -f /dev/null
    volumes:
      # Mount the current directory on the host to /app in the container
      # This allows for real-time code changes without rebuilding the image.
      - .:/app
      - .:/keys:/app/keys
      - ./staticfiles:/app/staticfiles
    ports:
      - "127.0.0.1:8000:8000" # Map port 8000 on the host to port 8000 in the container
    env_file:
      - ./.env.django
      - ./.env.vectorstore
      - ./.env.gemini # Load Django specific environment variables
    environment:
      - GOOGLE_APPLICATION_CREDENTIALS=/app/keys/service-account.json
    depends_on:
      db:
        condition: service_healthy # Wait for the 'db' service to be healthy before starting 'web'
    networks:
      - django_network

  pgadmin:
    image: dpage/pgadmin4 # Official pgAdmin4 image
    container_name: pgadmin_dev
    env_file:
      - ./.env.pgadmin # Load pgAdmin credentials
    ports:
      # Map pgAdmin's internal port 80 to host's port 5050, but only on localhost for Nginx.
      - "127.0.0.1:5050:80" # Access pgAdmin on http://localhost:5050 (pgAdmin listens on port 80 internally)
    depends_on:
      db:
        condition: service_healthy # Wait for the 'db' service to be healthy
    volumes:
      - pgadmin_dev_data:/var/lib/pgadmin # Persist pgAdmin user data and server configurations
    networks:
      - django_network
  redis:
    image: redis:7
    container_name: redis_dev
    ports:
      - "6379:6379"
    networks:
      - django_network
  
  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: celery_worker
    command: celery -A infiniti worker --loglevel=info
    volumes:
      - .:/app
      - ./keys:/app/keys  
    depends_on:
      - db
      - redis
    env_file:
      - .env.django
      - ./.env.vectorstore
      - ./.env.gemini
    environment:  
      - GOOGLE_APPLICATION_CREDENTIALS=/app/keys/service-account.json
    networks:
      - django_network

volumes:
  postgres_dev_data: # Defines the named volume for PostgreSQL data
  pgadmin_dev_data:  # Defines the named volume for pgAdmin data

networks:
  django_network: # Defines the bridge network for services to communicate
    driver: bridge
